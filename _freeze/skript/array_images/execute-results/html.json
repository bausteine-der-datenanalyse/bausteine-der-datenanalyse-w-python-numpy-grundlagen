{
  "hash": "bd62804eaf1e11040b6015a6e0afa1f2",
  "result": {
    "engine": "jupyter",
    "markdown": "## Arbeiten mit Bildern\n\n\n\nBilder werden digital als Matrizen gespeichert. Dabei werden pro Pixel drei \nFarbwerte (rot, grün, blau) gespeichert. Aus diesen drei Farbwerten (Wert 0-255) \nwerden dann alle gewünschten Farben zusammengestellt. \n\n![Ein hochaufgelöstes Bild besteht aus sehr vielen Pixeln. Jedes Pixel enthät 3 Farbwerte, einen für die Fabre Grün, einen für Blau und einen für Rot.](/skript/00-bilder/pixel_mona_lisa_split.svg){#fig-pixel_colors fig-alt=\"Schaubild, was zeigt, dass ein hochaufgelöstes Bild der Mona Lisa aus einzelnen Pixeln besteht, welche wiederum aus den drei Farben blau, rot und grün zusammengesetzt sind\"}\n\nAufgrund der digitalen Darstellung von Bildern lassen sich diese mit den \nWerkzeugen von NumPy leicht bearbeiten. \nWir verwenden für folgendes Beispiel als Bild die Monas Lisa. Das Bild ist unter folgendem [Link](https://upload.wikimedia.org/wikipedia/commons/thumb/6/6a/Mona_Lisa.jpg/677px-Mona_Lisa.jpg) zu finden.\n\n\nImportieren wir dieses Bild nun mit der Funktion `imread()`aus dem \nmatplotlib-package, sehen wir das es um ein dreidimensionales numpy Array \nhandelt. \n\n::: {#bc982b68 .cell execution_count=2}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n\ndata = plt.imread(\"00-bilder/mona_lisa.jpg\")\nprint(\"Form:\", data.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nForm: (1024, 677, 3)\n```\n:::\n:::\n\n\nSchauen wir uns einmal mit der `print()`-Funktion einen Ausschnitt dieser Daten an.\n\n::: {#108907e9 .cell execution_count=3}\n``` {.python .cell-code}\nprint(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[[ 68  62  38]\n  [ 88  82  56]\n  [ 92  87  55]\n  ...\n  [ 54  97  44]\n  [ 68 110  60]\n  [ 69 111  63]]\n\n [[ 65  59  33]\n  [ 68  63  34]\n  [ 83  78  46]\n  ...\n  [ 66 103  51]\n  [ 66 103  52]\n  [ 66 102  56]]\n\n [[ 97  90  62]\n  [ 87  80  51]\n  [ 78  72  38]\n  ...\n  [ 79 106  53]\n  [ 62  89  38]\n  [ 62  88  41]]\n\n ...\n\n [[ 25  14  18]\n  [ 21  10  14]\n  [ 20   9  13]\n  ...\n  [ 11   5   9]\n  [ 11   5   9]\n  [ 10   4   8]]\n\n [[ 23  12  16]\n  [ 23  12  16]\n  [ 21  10  14]\n  ...\n  [ 11   5   9]\n  [ 11   5   9]\n  [ 10   4   8]]\n\n [[ 22  11  15]\n  [ 26  15  19]\n  [ 24  13  17]\n  ...\n  [ 11   5   9]\n  [ 10   4   8]\n  [  9   3   7]]]\n```\n:::\n:::\n\n\nMit der Funktion `plt.imshow` kann das Bild in Echtfarben dargestellt werden. \nDies funktioniert, da die Funktion die einzelnen Ebenen, hier der letzte Index, \ndes Datensatzes als Farbinformationen (rot, grün, blau) interpretiert. Wäre \nnoch eine vierte Ebene dabei, würde sie als individueller Transparenzwert \nverwendet worden.\n\n::: {#f4139423 .cell execution_count=4}\n``` {.python .cell-code}\nplt.imshow(data)\n```\n\n::: {.cell-output .cell-output-display}\n![](array_images_files/figure-html/cell-5-output-1.png){width=307 height=416}\n:::\n:::\n\n\nNatürlich können auch die einzelnen Farbebenen individuell betrachtet werden. \nDazu wird der letzte Index festgehalten.\n\n::: {#d8b2bb1d .cell execution_count=5}\n``` {.python .cell-code}\n# Als Farbskale wird die Rotskala \n# verwendet 'Reds'\nplt.imshow( data[:,:,0], cmap='Reds' )\nplt.colorbar()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](array_images_files/figure-html/cell-6-output-1.png){width=386 height=416}\n:::\n:::\n\n\nDa die Bilddaten als Arrays gespeichert sind, sind viele der möglichen Optionen, \nz.B. zur Teilauswahl oder Operationen, verfügbar. Das untere Beispiel zeigt \neinen Ausschnitt im Rotkanal des Bildes.\n\n::: {#fa5a9302 .cell execution_count=6}\n``` {.python .cell-code}\nbereich = np.array(data[450:500, 550:600,0], dtype=float)\nplt.imshow( bereich, cmap=\"Greys\" )\nplt.colorbar()\n```\n\n::: {.cell-output .cell-output-display}\n![](array_images_files/figure-html/cell-7-output-1.png){width=494 height=412}\n:::\n:::\n\n\n",
    "supporting": [
      "array_images_files"
    ],
    "filters": [],
    "includes": {}
  }
}