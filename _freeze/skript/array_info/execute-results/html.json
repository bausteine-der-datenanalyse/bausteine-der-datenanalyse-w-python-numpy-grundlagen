{
  "hash": "fefb3514b355bcd290b9778a483e4529",
  "result": {
    "engine": "jupyter",
    "markdown": "# Größe, Struktur und Typ\n\n\n\nWenn man sich nicht mehr sicher ist, welche Struktur oder Form ein Array hat oder \noder diese Größen zum Beispiel für Schleifen nutzen möchte, bietet NumPy \nfolgende Funktionen für das Auslesen dieser Größen an.\n\n::: {#78c3869b .cell execution_count=2}\n``` {.python .cell-code}\nmatrix = np.array([[1, 2, 3], [4, 5, 6]])\n```\n:::\n\n\n`np.shape()` gibt die Längen der einzelnen Dimension in Form einer Liste zurück. \n\n::: {#010c5407 .cell execution_count=3}\n``` {.python .cell-code}\nnp.shape(matrix)\n```\n\n::: {.cell-output .cell-output-display execution_count=79}\n```\n(2, 3)\n```\n:::\n:::\n\n\nDie native Python Funktion `len()` gibt dagegen nur die Länge der ersten \nDimension, also die Anzahl der Elemente in den äußeren Klammern wieder. \n\n::: {#b8dc9b6c .cell execution_count=4}\n``` {.python .cell-code}\nlen(matrix)\n```\n\n::: {.cell-output .cell-output-display execution_count=80}\n```\n2\n```\n:::\n:::\n\n\nDie Funktion `np.ndym()`gibt im Gegensatz zu `np.shape()` nur die Anzahl der \nDimensionen zurück. \n\n::: {#a1da8fc9 .cell execution_count=5}\n``` {.python .cell-code}\nnp.ndim(matrix)\n```\n\n::: {.cell-output .cell-output-display execution_count=81}\n```\n2\n```\n:::\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n## Die Ausgabe von `np.ndim()` kann mit `np.size()`und einer nativen Python Funktion erreicht werden. Wie?\n\n`np.ndim()` gibt die Länge der Liste von `np.shape()` aus\n\n::: {#b63ac5b3 .cell execution_count=6}\n``` {.python .cell-code}\nlen(np.shape(matrix))\n```\n\n::: {.cell-output .cell-output-display execution_count=82}\n```\n2\n```\n:::\n:::\n\n\n:::\n\nMöchte man die Anzahl aller Elemente in einem Array ausgeben kann man die \nFunktion `np.size()` benutzen.\n\n::: {#12d7db54 .cell execution_count=7}\n``` {.python .cell-code}\nnp.size(matrix)\n```\n\n::: {.cell-output .cell-output-display execution_count=83}\n```\n6\n```\n:::\n:::\n\n\nNumPy Arrays können verschiedene Datentypen beinhalten. Im folgenden haben wir \ndrei verschiedene Arrays mit einem jeweils anderen Datentypen.\n\n::: {#29041ae8 .cell execution_count=8}\n``` {.python .cell-code}\ntyp_a = np.array([1, 2, 3, 4, 5, 6])\ntyp_b = np.array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6])\ntyp_c = np.array([\"Montag\", \"Dienstag\", \"Mittwoch\"])\n```\n:::\n\n\nMit der Methode `np.dtype` können wir den Datentypen von Arrays ausgeben lassen. Das Array *typ_a* beinhaltet den Datentypen int64, also ganze Zahlen.\n\n::: {#2735b18f .cell execution_count=9}\n``` {.python .cell-code}\nprint(typ_a.dtype)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nint64\n```\n:::\n:::\n\n\nDas Array *typ_b* beinhaltet den Datentypen float64, wobei float für Gleitkommazahlen steht.\n\n::: {#6da87758 .cell execution_count=10}\n``` {.python .cell-code}\nprint(typ_b.dtype)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfloat64\n```\n:::\n:::\n\n\nDas Array *typ_c* beinhaltet den Datentypen str, wobei float für Gleitkommazahlen steht.\n\n::: {#8e29cc2a .cell execution_count=11}\n``` {.python .cell-code}\nprint(typ_c.dtype)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<U8\n```\n:::\n:::\n\n\n",
    "supporting": [
      "array_info_files"
    ],
    "filters": [],
    "includes": {}
  }
}