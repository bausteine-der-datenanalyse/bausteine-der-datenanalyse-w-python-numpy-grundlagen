{
  "hash": "258c5e8f3903e6870c9b7e350e7e0830",
  "result": {
    "engine": "jupyter",
    "markdown": "# Rechnen mit Arrays\n\n## Arithemtische Funktionen\n\n\n\nEin großer Vorteil an NumPy ist das Rechnen mit Arrays. Ohne NumPy müsste man \nentweder eine `Schleife` oder aber `List comprehension` benutzen, um mit \nsämtlichen Werten in der Liste zu rechnen. In NumPy fällt diese Unannehmlichkeit \nweg.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\na = np.array([1, 2, 3, 4, 5])\n\nb = np.array([9, 8, 7, 6, 5])\n```\n:::\n\n\nNormale mathematische Operationen, wie die Addition, lassen sich auf zwei Arten \nausdrücken. Entweder über die `np.add()` Funktion oder aber simpel über das `+` \nZeichen.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nnp.add(a,b)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\narray([10, 10, 10, 10, 10])\n```\n:::\n:::\n\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\na + b\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\narray([10, 10, 10, 10, 10])\n```\n:::\n:::\n\n\nFür die anderen Rechenarten existieren auch Funktionen: `np.subtract()`, \n`np.multiply()` und `np.divide()`. \n\nAuch für die anderen höheren Rechenoperationen gibt es ebenfalls Funktionen:\n\n* `np.exp(a)`\n* `np.sqrt(a)`\n* `np.power(a, 3)`\n* `np.sin(a)`\n* `np.cos(a)`\n* `np.tan(a)`\n* `np.log(a)`\n* `a.dot(b)`\n\n::: {.callout-warning}\n\n## Arbeiten mit Winkelfunktionen\n\nWie auch am Taschenrechner birgt das Arbeiten mit den Winkelfunktionen \n(sin, cos, ...) die Fehlerquelle, dass man nicht mit Radian-Werten, sondern mit \nGrad-Werten arbeitet. Die Winkelfunktionen in numpy erwarten jedoch \nRadian-Werte. \n\nFür eine einfache Umrechnung bietet NumPy die Funktionen `np.grad2rad()`und \n`np.rad2grad()`.\n\n:::\n\n## Vergleiche\n\nNumPy-Arrays lassen sich auch miteinander vergleichen. Betrachten wir die \nfolgenden zwei Arrays:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\na = np.array([1, 2, 3, 4, 5])\n\nb = np.array([9, 2, 7, 4, 5])\n```\n:::\n\n\nMöchten wir feststellen, ob diese zwei Arrays identisch sind, können wir \nden `==`-Komparator benutzen. Dieser vergleicht die Arrays elementweise.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\na == b\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\narray([False,  True, False,  True,  True])\n```\n:::\n:::\n\n\nEs ist außerdem möglich Arrays mit den `>`- und `<`-Operatoren zu vergleichen:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\na < b\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\narray([ True, False,  True, False, False])\n```\n:::\n:::\n\n\nMöchte man Arrays mit Gleitkommazahlen vergleichen, ist es oftmals nötig, eine \ngewisse Toleranz zu benutzen, da bei Rechenoperationen minimale Rundungsfehler \nentstehen können. \n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\na = np.array(0.1 + 0.2)\nb = np.array(0.3)\na == b\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\nFalse\n```\n:::\n:::\n\n\nFür diesen Fall gibt es eine Vergleichsfunktion `np.isclose(a,b,atol)`, wobei \n`atol` für die absolute Toleranz steht. Im folgenden Beispiel wird eine absolute \nToleranz von 0,001 verwendet.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\na = np.array(0.1 + 0.2)\nb = np.array(0.3)\nprint(np.isclose(a, b, atol=0.001))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\n```\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n\n## Warum ist 0.1 + 0.2 nicht gleich 0.3?\n\nZahlen werden intern als Binärzahlen dargestellt. So wie 1/3 nicht mit einer \nendlichen Anzahl an Ziffern korrekt dargestellt werden kann müssen Zahlen ggf. \ngerundet werden, um im Binärsystem dargestellt zu werden. \n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\na = 0.1\nb = 0.2\nprint(a + b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.30000000000000004\n```\n:::\n:::\n\n\n:::\n\n## Aggregatfunktionen\n\nFür verschiedene Auswertungen benötigen wir Funktionen, wie etwa die Summen \noder die Mittelwert-Funktion. Starten wir mit einem Beispiel Array a:\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\na = np.array([1, 2, 3, 4, 8])\n```\n:::\n\n\nDie Summer wird über die Funktion `np.sum()` berechnet.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nnp.sum(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n18\n```\n:::\n:::\n\n\nNatürlich lassen sich auch der Minimalwert und der Maximalwert eines Arrays \nermitteln. Die beiden Funktionen lauten `np.min()`und `np.max()`. \n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nnp.min(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n1\n```\n:::\n:::\n\n\nMöchte man nicht das Maximum selbst, sondern die Position des Maximums bestimmen, \nwird statt `np.max` die Funktion `np.argmax`verwendet.\n\nFür statistische Auswertungen werden häufig die Funktion für den Mittelwert \n`np.mean()`, die Funktion für den Median `np.median()`und die Funktion für die \nStandardabweichung `np.std()`verwendet.\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nnp.mean(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n3.6\n```\n:::\n:::\n\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nnp.median(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n3.0\n```\n:::\n:::\n\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nnp.std(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n2.4166091947189146\n```\n:::\n:::\n\n\n<!-- \n::: {.callout-tip collapse=\"true\"}\n\n## Übung: Rechnen mit Arrays\n\n\n\n::: {.callout-caution icon=\"false\" collapse=\"true\"}\n\n\n## Lösung\n\n:::\n\n::: -->\n\n",
    "supporting": [
      "array_calculation_files/figure-pdf"
    ],
    "filters": []
  }
}